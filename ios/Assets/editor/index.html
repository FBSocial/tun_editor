<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,minimum-scale=1.0,maximum-scale=1.0"/>
    <title>Tun Editor</title>
    <link rel="stylesheet" href="normalize.css" type="text/css" charset="utf-8">
    <link rel="stylesheet" href="snow.css" type="text/css" charset="utf-8">
    <link rel="stylesheet" href="highlight.min.css" type="text/css" charset="utf-8">
    <script src="highlight.min.js" charset="utf-8"></script>
    <script src="highlightjs-line-numbers.min.js" charset="utf-8"></script>
    <script src="markdown.js" charset="utf-8"></script>
    <script src="quill2.min.js" charset="utf-8"></script>
    <script src="quill.mention.min.js" charset="utf-8"></script>
    <style>
      .ql-container {
        font-size: 16px;
        color: #363940;
      }
      .ql-container.ql-snow {
         border: none !important;
         height: 100vh;
       }
      .ql-editor {
        line-height: 1.5;
      }
      .ql-snow .ql-editor h1 {
        font-size: 22px;
      }
      .ql-snow .ql-editor h2 {
        font-size: 20px;
      }
      .ql-snow .ql-editor h3 {
        font-size: 18px;
      }
      .ql-editor ol li:before {
        color: #5562F2;
        font-size: 16px;
      }
      .ql-editor ul > li::before {
        color: #5562F2;
      }
      .ql-editor ol,
      .ql-editor ul {
        padding-left: 3px;
      }
      .ql-editor ol li:not(.ql-direction-rtl),
      .ql-editor ul li:not(.ql-direction-rtl) {
        padding-left: 20px;
      }
      .ql-editor ul > li::before {
        width: 12px;
      }
      .ql-editor li:not(.ql-direction-rtl)::before {
        text-align: left;
        margin-left: -20px;
        margin-right: 8px;
      }
      .ql-editor li::before {
        width: auto;
      }
      hr {
        border: 0 none;
        height: 1px;
        color: #8f959e1e;
        background-color: #8f959e1e;
      }
      .ql-snow .ql-editor blockquote {
        border-left: 2px solid #5562F2;
        padding-left: 12px;
        color: #646A73;
      }
      .ql-editor .ql-code-block-container,
      .ql-snow .ql-editor pre.ql-syntax {
        font-size: 14px;
        color: #646A73;
        background-color: #F5F5F8;
        border-radius: 4px;
        border: 0.5px solid #8f959e14;
        margin: 5px 0;
        padding: 16px 24px;
        box-sizing: border-box;
        counter-reset: line-numbering;
      }
      .ql-snow a {
        color: #5562F2;
      }
      .ql-editor .ql-code-block::before,
      pre .hljs-line::before {
        display: inline-block;
        content: counter(line-numbering) '.';
        counter-increment: line-numbering;
        width: 30px;
        text-align: right;
        margin-left: -16px;
        margin-right: 16px;
      }
      span.mention {
        background-color: #5562F2;
        padding: 2px 12px;
        border-radius: 20px;
        color: #FFFFFF;
      }
      .ql-snow .ql-editor blockquote {
        margin: 0;
      }
      .ql-editor .ql-video {
        display: flex;
        position: relative;
        margin: 0;
        padding: 0;
      }
      .ql-editor .ql-video video {
        max-width: 100%;
      }
      .ql-editor .ql-video .video-duration-mask {
        position: absolute;
        bottom: 4px;
        right: 4px;
        background: #0000008C;
        color: #FFFFFF;
        padding: 2px;
        width: 60px;
        height: 24px;
        font-size: 13px;
        text-align: center;
        border-radius: 12px;
        display: flex;
        justify-content: center;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <div id="editor"></div>

    <script>
      let u = navigator.userAgent;
      let isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;
      let isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
      // let isAndroid = false;
      // let isIOS = false;
      let bridge = {
        onTextChange: function(delta, oldDelta, source) {
          if (isAndroid) {
            tun.onTextChange(delta, oldDelta, source);
          } else if (isIOS) {
            window.webkit.messageHandlers.onTextChange.postMessage({
               delta: delta,
               oldDelta: oldDelta,
               source: source,
            });
          }
        },
        onSelectionChange: function(index, length, format) {
          if (isAndroid) {
            tun.onSelectionChange(index, length, format);
          } else if (isIOS) {
            window.webkit.messageHandlers.onSelectionChange.postMessage({
               index: index,
               length: length,
               format: format,
            });
          }
        },
        onMentionClick: function(id, text) {
          if (isAndroid) {
            tun.onMentionClick(id, text);
          } else if (isIOS) {
            window.webkit.messageHandlers.onMentionClick.postMessage({
               id: id,
               text: text,
            });
          }
        },
        onLinkClick: function(url) {
          if (isAndroid) {
            tun.onLinkClick(url);
          } else if (isIOS) {
            window.webkit.messageHandlers.onLinkClick.postMessage({
               url: url,
            });
          }
        },
        onFocusChange: function(hasFocus) {
          if (isAndroid) {
            tun.onFocusChange(hasFocus);
          } else if (isIOS) {
            window.webkit.messageHandlers.onFocusChange.postMessage({
               hasFocus: hasFocus,
            });
          }
        },
      }

      var replaceText;
      var setContents;
      var updateContents;
      var format;
      var formatText;
      var setSelection;
      var focus;
      var blur;
      var setPlaceholder;
      var setReadOnly;
      var setPadding;

      document.addEventListener('DOMContentLoaded', () => {
        let Delta = Quill.import('delta');
        let Keyboard = Quill.import('modules/keyboard');
        let BlockEmbed = Quill.import('blots/block/embed');
        let Container = Quill.import('blots/container');
        let Image = Quill.import('formats/image');

        class DividerBlot extends BlockEmbed {

          static create(type) {
            let node = super.create();
            node.setAttribute('type', type);
            return node;
          }

          static value(node) {
            return node.getAttribute('type');
          }

        }
        DividerBlot.blotName = 'divider';
        DividerBlot.tagName = 'hr';
        Quill.register(DividerBlot, true);

        class ImageExtend extends Image {
          static create(value) {
            let node = super.create(value);
            if (typeof value === 'string') {
              node.setAttribute('src', this.sanitize(value));
              node.setAttribute('data-src', this.sanitize(value));
            }
            node.onerror = function() {
              node.setAttribute('src', 'common_lost.svg');
            }
            return node;
          }
          static value(domNode) {
            return domNode.getAttribute('data-src');
          }
        }
        Quill.register(ImageExtend, true);

        class VideoBlot extends BlockEmbed {

          static create(value) {
            const node = super.create(value);
            node.setAttribute('src', this.sanitize(value));

            const video = document.createElement("video");
            video.innerHTML = node.duration;
            video.setAttribute('src', this.sanitize(value));
            video.controls = false;
            video.ontimeupdate = function() {
              const durationSpan = document.createElement("div");
              durationSpan.className = 'video-duration-mask';
              if (video.duration) {
                let minute = parseInt(video.duration / 60);
                let second = parseInt(video.duration % 60);
                durationSpan.innerHTML = `<svg t="1629367052116" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9336" xmlns:xlink="http://www.w3.org/1999/xlink" width="15" height="15"><defs><style type="text/css">@font-face { font-family: element-icons; src: url("chrome-extension://moombeodfomdpjnpocobemoiaemednkg/fonts/element-icons.woff") format("woff"), url("chrome-extension://moombeodfomdpjnpocobemoiaemednkg/fonts/element-icons.ttf ") format("truetype"); }
</style></defs><path d="M896 305.066667a72.533333 72.533333 0 0 0-78.933333 12.8l-91.733334 85.333333V341.333333a128 128 0 0 0-128-128H213.333333a128 128 0 0 0-128 128v341.333334a128 128 0 0 0 128 128h384a128 128 0 0 0 128-128v-61.866667l92.16 85.333333a74.24 74.24 0 0 0 49.493334 19.2 71.68 71.68 0 0 0 29.44-6.4 68.266667 68.266667 0 0 0 42.666666-63.146666V368.213333A68.266667 68.266667 0 0 0 896 305.066667z" fill="#FFFFFF" p-id="9337"></path></svg> ${minute}:${second}`;
              } else {
                durationSpan.innerHTML = '00:00';
              }
              durationSpan.setAttribute('contenteditable', false);
              node.appendChild(durationSpan);
            }
            node.appendChild(video);
            return node;
          }

          static formats(domNode) {
            return ['width', 'height'].reduce((formats, attribute) => {
              if (domNode.hasAttribute(attribute)) {
                formats[attribute] = domNode.getAttribute(attribute);
              }
              return formats;
            }, {});
          }

          static sanitize(url) {
            let protocols = ['http', 'https', 'mailto', 'tel'];
            const anchor = document.createElement('a');
            anchor.href = url;
            const protocol = anchor.href.slice(0, anchor.href.indexOf(':'));
            let isValid = protocols.indexOf(protocol) > -1;
            return isValid ? `${url}#t=0.1` : 'about:blank';
          }

          static value(domNode) {
            return domNode.getAttribute('src');
          }

          format(name, value) {
            let videoNode = this.domNode.querySelector('video');
            if (name === 'width' || name === 'height' && videoNode) {
              if (value) {
                this.domNode.style[name] = `${value}px`;
                videoNode.setAttribute(name, value);
              } else {
                this.domNode.style[name] = null;
                videoNode.removeAttribute(name);
              }
            } else {
              super.format(name, value);
            }
          }

        }
        VideoBlot.blotName = 'video';
        VideoBlot.className = 'ql-video';
        VideoBlot.tagName = 'DIV';
        Quill.register(VideoBlot, true);

        let bindings = {
          'code exit': {
            key: 'Enter',
            collapsed: true,
            format: ['code-block'],
            prefix: /^$/,
            suffix: /^\s*$/,
            handler: function(range, context) {
              const [line, offset] = this.quill.getLine(range.index);
              let numLines = 1;
              let cur = line;
              while (
                cur != null &&
                cur.length() <= 1 &&
                cur.formats()['code-block'] &&
                (cur.next === null || !cur.next.formats()['code-block'])
              ) {
                cur = cur.prev;
                numLines -= 1;
                // Requisite prev lines are empty
                if (numLines <= 0) {
                  const delta = new Delta()
                    .retain(range.index + line.length() - offset - 1)
                    .retain(1, { 'code-block': null })
                    .delete(1);
                  this.quill.updateContents(delta, Quill.sources.USER);
                  this.quill.setSelection(range.index, Quill.sources.SILENT);
                  return false;
                }
              }
              return true;
            }
          },
          'code delete': {
            key: 'Backspace',
            collapsed: true,
            format: ['code-block'],
            prefix: /^$/,
            suffix: /^\s*$/,
            handler: function(range) {
              this.quill.format('code-block', false, Quill.sources.USER);
            }
          },
          'blockquote delete': {
            key: 'Backspace',
            collapsed: true,
            format: ['blockquote'],
            prefix: /^$/,
            suffix: /^$/,
            handler: function(range) {
              this.quill.format('blockquote', false, Quill.sources.USER);
            }
          },
          'header delete': {
            key: 'Backspace',
            collapsed: true,
            format: ['header'],
            prefix: /^$/,
            suffix: /^$/,
            handler: function(range) {
              this.quill.format('header', false, Quill.sources.USER);
            }
          }
        }
        var options = {
          readOnly: false,
          theme: 'snow',
          modules: {
            syntax: false,
            toolbar: false,
            keyboard: {
              bindings: bindings
            },
            mention: {
              mentionDenotationChars: ["@"],
              source: async function(searchTerm, renderList) {
              },
            },
          }
        };
        var quill = new Quill('#editor', options);
        quill.root.addEventListener('click', (ev) => {
          if (ev.target.tagName === 'A') {
            // Link click.
            bridge.onLinkClick(ev.target.href);
            ev.preventDefault();
          }

          // Mention click.
          if (ev.target.tagName === 'SPAN') {
            if (ev.target.className === 'mention') {
              bridge.onMentionClick(ev.target.attributes['data-id'].value, ev.target.attributes['data-value'].value);
            } else if (ev.target.className === 'ql-mention-denotation-char') {
              let mentionNode = ev.target.parentElement.parentElement;
              bridge.onMentionClick(mentionNode.attributes['data-id'].value, mentionNode.attributes['data-value'].value);
            } else if (ev.target.attributes['contenteditable']
                  && ev.target.attributes['contenteditable'].value === 'false'
                  && ev.target.parentElement.className === 'mention') {
              let mentionNode = ev.target.parentElement;
              bridge.onMentionClick(mentionNode.attributes['data-id'].value, mentionNode.attributes['data-value'].value);
            }
          }
        });

        quill.on('text-change', function(delta, oldDelta, source) {
          if (source === Quill.sources.SILENT) {
            return;
          }
          bridge.onTextChange(JSON.stringify(delta), JSON.stringify(oldDelta), source);

          setTimeout(function() {
            let range = quill.getSelection(true);
            if (range) {
              var format = quill.getFormat();
              bridge.onSelectionChange(range.index, range.length, JSON.stringify(format));
            }
          }, 200);
        });
        quill.on('selection-change', function(range, oldRange, source) {
          if (range) {
            var format = quill.getFormat()
            bridge.onSelectionChange(range.index, range.length, JSON.stringify(format));
          }
        });
        quill.root.addEventListener('blur', function() {
          bridge.onFocusChange(false);
        });
        quill.root.addEventListener('focus', function() {
          bridge.onFocusChange(true);
        });

        var markdownOptions = {
          ignoreTags: [ 'h4', 'h5', 'h6' ], // @option - if you need to ignore some tags.
        };
        new QuillMarkdown(quill, markdownOptions);

        replaceText = function(index, length, data, attributes, newLineAfterImage, isEmbeddable) {
          if (isEmbeddable) {
            var delta = new Delta().retain(index).delete(length).insert(data, attributes)
            if (Object.keys(data).length > 0
                    && Object.keys(data)[0] === 'image'
                    && newLineAfterImage) {
              delta = delta.insert('\n');
            }
            quill.updateContents(delta);
          } else {
            let delta = new Delta().retain(index).delete(length).insert(data, attributes)
            quill.updateContents(delta);
          }
        }
        setContents = function(delta) {
          quill.setContents(delta, Quill.sources.SILENT);
        }
        updateContents = function(delta, source) {
          quill.updateContents(delta, source);
        }
        format = function(name, value) {
          quill.format(name, value, 'user');
        }
        formatText = function(index, length, format, value) {
          quill.formatText(index, length, format, value, Quill.sources.USER);
        }
        setSelection = function(index, length) {
          quill.setSelection(index, length, Quill.sources.API)
        }
        focus = function() {
          quill.focus();
        }
        blur = function() {
          quill.blur();
        }
        setPlaceholder = function(placeholder) {
          quill.root.dataset.placeholder = placeholder;
        }
        setReadOnly = function(readOnly) {
          quill.enable(!readOnly);
        }
        setPadding = function(top, right, bottom, left) {
          var editor = document.querySelector('.ql-editor');
          editor.style.padding = `${top}px ${right}px ${bottom}px ${left}px`;
        }
      })
    </script>
  </body>
</html>
